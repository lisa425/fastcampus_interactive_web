{"version":3,"file":"index.umd.js","sources":["../node_modules/@swup/plugin/dist/index.modern.js","../node_modules/path-to-regexp/dist.es2015/index.js","../src/animations.ts","../src/index.ts"],"sourcesContent":["function r(){return r=Object.assign?Object.assign.bind():function(r){for(var n=1;n<arguments.length;n++){var e=arguments[n];for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(r[t]=e[t])}return r},r.apply(this,arguments)}const n=r=>String(r).split(\".\").map(r=>String(parseInt(r||\"0\",10))).concat([\"0\",\"0\"]).slice(0,3).join(\".\");class e{constructor(){this.isSwupPlugin=!0,this.swup=void 0,this.version=void 0,this.requires={},this.handlersToUnregister=[]}mount(){}unmount(){this.handlersToUnregister.forEach(r=>r()),this.handlersToUnregister=[]}_beforeMount(){if(!this.name)throw new Error(\"You must define a name of plugin when creating a class.\")}_afterUnmount(){}_checkRequirements(){return\"object\"!=typeof this.requires||Object.entries(this.requires).forEach(([r,e])=>{if(!function(r,e,t){const s=function(r,n){var e;if(\"swup\"===r)return null!=(e=n.version)?e:\"\";{var t;const e=n.findPlugin(r);return null!=(t=null==e?void 0:e.version)?t:\"\"}}(r,t);return!!s&&((r,e)=>e.every(e=>{const[,t,s]=e.match(/^([\\D]+)?(.*)$/)||[];var o,i;return((r,n)=>{const e={\"\":r=>0===r,\">\":r=>r>0,\">=\":r=>r>=0,\"<\":r=>r<0,\"<=\":r=>r<=0};return(e[n]||e[\"\"])(r)})((i=s,o=n(o=r),i=n(i),o.localeCompare(i,void 0,{numeric:!0})),t||\">=\")}))(s,e)}(r,e=Array.isArray(e)?e:[e],this.swup)){const n=`${r} ${e.join(\", \")}`;throw new Error(`Plugin version mismatch: ${this.name} requires ${n}`)}}),!0}on(r,n,e={}){var t;n=!(t=n).name.startsWith(\"bound \")||t.hasOwnProperty(\"prototype\")?n.bind(this):n;const s=this.swup.hooks.on(r,n,e);return this.handlersToUnregister.push(s),s}once(n,e,t={}){return this.on(n,e,r({},t,{once:!0}))}before(n,e,t={}){return this.on(n,e,r({},t,{before:!0}))}replace(n,e,t={}){return this.on(n,e,r({},t,{replace:!0}))}off(r,n){return this.swup.hooks.off(r,n)}}export{e as default};\n//# sourceMappingURL=index.modern.js.map\n","/**\n * Tokenize input string.\n */\nfunction lexer(str) {\n    var tokens = [];\n    var i = 0;\n    while (i < str.length) {\n        var char = str[i];\n        if (char === \"*\" || char === \"+\" || char === \"?\") {\n            tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"\\\\\") {\n            tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n            continue;\n        }\n        if (char === \"{\") {\n            tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"}\") {\n            tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \":\") {\n            var name = \"\";\n            var j = i + 1;\n            while (j < str.length) {\n                var code = str.charCodeAt(j);\n                if (\n                // `0-9`\n                (code >= 48 && code <= 57) ||\n                    // `A-Z`\n                    (code >= 65 && code <= 90) ||\n                    // `a-z`\n                    (code >= 97 && code <= 122) ||\n                    // `_`\n                    code === 95) {\n                    name += str[j++];\n                    continue;\n                }\n                break;\n            }\n            if (!name)\n                throw new TypeError(\"Missing parameter name at \".concat(i));\n            tokens.push({ type: \"NAME\", index: i, value: name });\n            i = j;\n            continue;\n        }\n        if (char === \"(\") {\n            var count = 1;\n            var pattern = \"\";\n            var j = i + 1;\n            if (str[j] === \"?\") {\n                throw new TypeError(\"Pattern cannot start with \\\"?\\\" at \".concat(j));\n            }\n            while (j < str.length) {\n                if (str[j] === \"\\\\\") {\n                    pattern += str[j++] + str[j++];\n                    continue;\n                }\n                if (str[j] === \")\") {\n                    count--;\n                    if (count === 0) {\n                        j++;\n                        break;\n                    }\n                }\n                else if (str[j] === \"(\") {\n                    count++;\n                    if (str[j + 1] !== \"?\") {\n                        throw new TypeError(\"Capturing groups are not allowed at \".concat(j));\n                    }\n                }\n                pattern += str[j++];\n            }\n            if (count)\n                throw new TypeError(\"Unbalanced pattern at \".concat(i));\n            if (!pattern)\n                throw new TypeError(\"Missing pattern at \".concat(i));\n            tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n            i = j;\n            continue;\n        }\n        tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n    }\n    tokens.push({ type: \"END\", index: i, value: \"\" });\n    return tokens;\n}\n/**\n * Parse a string for the raw tokens.\n */\nexport function parse(str, options) {\n    if (options === void 0) { options = {}; }\n    var tokens = lexer(str);\n    var _a = options.prefixes, prefixes = _a === void 0 ? \"./\" : _a;\n    var defaultPattern = \"[^\".concat(escapeString(options.delimiter || \"/#?\"), \"]+?\");\n    var result = [];\n    var key = 0;\n    var i = 0;\n    var path = \"\";\n    var tryConsume = function (type) {\n        if (i < tokens.length && tokens[i].type === type)\n            return tokens[i++].value;\n    };\n    var mustConsume = function (type) {\n        var value = tryConsume(type);\n        if (value !== undefined)\n            return value;\n        var _a = tokens[i], nextType = _a.type, index = _a.index;\n        throw new TypeError(\"Unexpected \".concat(nextType, \" at \").concat(index, \", expected \").concat(type));\n    };\n    var consumeText = function () {\n        var result = \"\";\n        var value;\n        while ((value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\"))) {\n            result += value;\n        }\n        return result;\n    };\n    while (i < tokens.length) {\n        var char = tryConsume(\"CHAR\");\n        var name = tryConsume(\"NAME\");\n        var pattern = tryConsume(\"PATTERN\");\n        if (name || pattern) {\n            var prefix = char || \"\";\n            if (prefixes.indexOf(prefix) === -1) {\n                path += prefix;\n                prefix = \"\";\n            }\n            if (path) {\n                result.push(path);\n                path = \"\";\n            }\n            result.push({\n                name: name || key++,\n                prefix: prefix,\n                suffix: \"\",\n                pattern: pattern || defaultPattern,\n                modifier: tryConsume(\"MODIFIER\") || \"\",\n            });\n            continue;\n        }\n        var value = char || tryConsume(\"ESCAPED_CHAR\");\n        if (value) {\n            path += value;\n            continue;\n        }\n        if (path) {\n            result.push(path);\n            path = \"\";\n        }\n        var open = tryConsume(\"OPEN\");\n        if (open) {\n            var prefix = consumeText();\n            var name_1 = tryConsume(\"NAME\") || \"\";\n            var pattern_1 = tryConsume(\"PATTERN\") || \"\";\n            var suffix = consumeText();\n            mustConsume(\"CLOSE\");\n            result.push({\n                name: name_1 || (pattern_1 ? key++ : \"\"),\n                pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,\n                prefix: prefix,\n                suffix: suffix,\n                modifier: tryConsume(\"MODIFIER\") || \"\",\n            });\n            continue;\n        }\n        mustConsume(\"END\");\n    }\n    return result;\n}\n/**\n * Compile a string to a template function for the path.\n */\nexport function compile(str, options) {\n    return tokensToFunction(parse(str, options), options);\n}\n/**\n * Expose a method for transforming tokens into the path function.\n */\nexport function tokensToFunction(tokens, options) {\n    if (options === void 0) { options = {}; }\n    var reFlags = flags(options);\n    var _a = options.encode, encode = _a === void 0 ? function (x) { return x; } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;\n    // Compile all the tokens into regexps.\n    var matches = tokens.map(function (token) {\n        if (typeof token === \"object\") {\n            return new RegExp(\"^(?:\".concat(token.pattern, \")$\"), reFlags);\n        }\n    });\n    return function (data) {\n        var path = \"\";\n        for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n            if (typeof token === \"string\") {\n                path += token;\n                continue;\n            }\n            var value = data ? data[token.name] : undefined;\n            var optional = token.modifier === \"?\" || token.modifier === \"*\";\n            var repeat = token.modifier === \"*\" || token.modifier === \"+\";\n            if (Array.isArray(value)) {\n                if (!repeat) {\n                    throw new TypeError(\"Expected \\\"\".concat(token.name, \"\\\" to not repeat, but got an array\"));\n                }\n                if (value.length === 0) {\n                    if (optional)\n                        continue;\n                    throw new TypeError(\"Expected \\\"\".concat(token.name, \"\\\" to not be empty\"));\n                }\n                for (var j = 0; j < value.length; j++) {\n                    var segment = encode(value[j], token);\n                    if (validate && !matches[i].test(segment)) {\n                        throw new TypeError(\"Expected all \\\"\".concat(token.name, \"\\\" to match \\\"\").concat(token.pattern, \"\\\", but got \\\"\").concat(segment, \"\\\"\"));\n                    }\n                    path += token.prefix + segment + token.suffix;\n                }\n                continue;\n            }\n            if (typeof value === \"string\" || typeof value === \"number\") {\n                var segment = encode(String(value), token);\n                if (validate && !matches[i].test(segment)) {\n                    throw new TypeError(\"Expected \\\"\".concat(token.name, \"\\\" to match \\\"\").concat(token.pattern, \"\\\", but got \\\"\").concat(segment, \"\\\"\"));\n                }\n                path += token.prefix + segment + token.suffix;\n                continue;\n            }\n            if (optional)\n                continue;\n            var typeOfMessage = repeat ? \"an array\" : \"a string\";\n            throw new TypeError(\"Expected \\\"\".concat(token.name, \"\\\" to be \").concat(typeOfMessage));\n        }\n        return path;\n    };\n}\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nexport function match(str, options) {\n    var keys = [];\n    var re = pathToRegexp(str, keys, options);\n    return regexpToFunction(re, keys, options);\n}\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nexport function regexpToFunction(re, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.decode, decode = _a === void 0 ? function (x) { return x; } : _a;\n    return function (pathname) {\n        var m = re.exec(pathname);\n        if (!m)\n            return false;\n        var path = m[0], index = m.index;\n        var params = Object.create(null);\n        var _loop_1 = function (i) {\n            if (m[i] === undefined)\n                return \"continue\";\n            var key = keys[i - 1];\n            if (key.modifier === \"*\" || key.modifier === \"+\") {\n                params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {\n                    return decode(value, key);\n                });\n            }\n            else {\n                params[key.name] = decode(m[i], key);\n            }\n        };\n        for (var i = 1; i < m.length; i++) {\n            _loop_1(i);\n        }\n        return { path: path, index: index, params: params };\n    };\n}\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str) {\n    return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options) {\n    return options && options.sensitive ? \"\" : \"i\";\n}\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path, keys) {\n    if (!keys)\n        return path;\n    var groupsRegex = /\\((?:\\?<(.*?)>)?(?!\\?)/g;\n    var index = 0;\n    var execResult = groupsRegex.exec(path.source);\n    while (execResult) {\n        keys.push({\n            // Use parenthesized substring match if available, index otherwise\n            name: execResult[1] || index++,\n            prefix: \"\",\n            suffix: \"\",\n            modifier: \"\",\n            pattern: \"\",\n        });\n        execResult = groupsRegex.exec(path.source);\n    }\n    return path;\n}\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(paths, keys, options) {\n    var parts = paths.map(function (path) { return pathToRegexp(path, keys, options).source; });\n    return new RegExp(\"(?:\".concat(parts.join(\"|\"), \")\"), flags(options));\n}\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(path, keys, options) {\n    return tokensToRegexp(parse(path, options), keys, options);\n}\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nexport function tokensToRegexp(tokens, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function (x) { return x; } : _d, _e = options.delimiter, delimiter = _e === void 0 ? \"/#?\" : _e, _f = options.endsWith, endsWith = _f === void 0 ? \"\" : _f;\n    var endsWithRe = \"[\".concat(escapeString(endsWith), \"]|$\");\n    var delimiterRe = \"[\".concat(escapeString(delimiter), \"]\");\n    var route = start ? \"^\" : \"\";\n    // Iterate over the tokens and create our regexp string.\n    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {\n        var token = tokens_1[_i];\n        if (typeof token === \"string\") {\n            route += escapeString(encode(token));\n        }\n        else {\n            var prefix = escapeString(encode(token.prefix));\n            var suffix = escapeString(encode(token.suffix));\n            if (token.pattern) {\n                if (keys)\n                    keys.push(token);\n                if (prefix || suffix) {\n                    if (token.modifier === \"+\" || token.modifier === \"*\") {\n                        var mod = token.modifier === \"*\" ? \"?\" : \"\";\n                        route += \"(?:\".concat(prefix, \"((?:\").concat(token.pattern, \")(?:\").concat(suffix).concat(prefix, \"(?:\").concat(token.pattern, \"))*)\").concat(suffix, \")\").concat(mod);\n                    }\n                    else {\n                        route += \"(?:\".concat(prefix, \"(\").concat(token.pattern, \")\").concat(suffix, \")\").concat(token.modifier);\n                    }\n                }\n                else {\n                    if (token.modifier === \"+\" || token.modifier === \"*\") {\n                        route += \"((?:\".concat(token.pattern, \")\").concat(token.modifier, \")\");\n                    }\n                    else {\n                        route += \"(\".concat(token.pattern, \")\").concat(token.modifier);\n                    }\n                }\n            }\n            else {\n                route += \"(?:\".concat(prefix).concat(suffix, \")\").concat(token.modifier);\n            }\n        }\n    }\n    if (end) {\n        if (!strict)\n            route += \"\".concat(delimiterRe, \"?\");\n        route += !options.endsWith ? \"$\" : \"(?=\".concat(endsWithRe, \")\");\n    }\n    else {\n        var endToken = tokens[tokens.length - 1];\n        var isEndDelimited = typeof endToken === \"string\"\n            ? delimiterRe.indexOf(endToken[endToken.length - 1]) > -1\n            : endToken === undefined;\n        if (!strict) {\n            route += \"(?:\".concat(delimiterRe, \"(?=\").concat(endsWithRe, \"))?\");\n        }\n        if (!isEndDelimited) {\n            route += \"(?=\".concat(delimiterRe, \"|\").concat(endsWithRe, \")\");\n        }\n    }\n    return new RegExp(route, flags(options));\n}\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nexport function pathToRegexp(path, keys, options) {\n    if (path instanceof RegExp)\n        return regexpToRegexp(path, keys);\n    if (Array.isArray(path))\n        return arrayToRegexp(path, keys, options);\n    return stringToRegexp(path, keys, options);\n}\n//# sourceMappingURL=index.js.map","import { isPromise, matchPath } from 'swup';\nimport type { Path, Visit } from 'swup';\n\nimport { MatchFunction, MatchOptions } from './index.js';\n\n/**\n * Animation object as supplied by plugin users.\n * Contains path patterns and handler functions for in/out animation.\n */\nexport type Animation = {\n\t/** The path pattern to match the current url against. */\n\tfrom: Path;\n\t/** The path pattern to match the next url against. */\n\tto: Path;\n\t/** The function to call when the animation is triggered. */\n\tout: (done: () => void, data: AnimationData) => void | Promise<void>;\n\t/** The function to call when the animation is triggered. */\n\tin: (done: () => void, data: AnimationData) => void | Promise<void>;\n};\n\n/**\n * Compiled animation object with pre-optimized match functions.\n */\nexport type CompiledAnimation = Animation & {\n\t/** Match function to check if the `from` pattern matches a given URL */\n\tmatchesFrom: MatchFunction;\n\t/** Match function to check if the `to` pattern matches a given URL */\n\tmatchesTo: MatchFunction;\n};\n\n/**\n * Data object passed into the animation handler functions.\n */\nexport type AnimationData = {\n\tvisit: Visit;\n\tdirection: 'in' | 'out';\n\tfrom: {\n\t\turl: string;\n\t\tpattern: Path;\n\t\tparams: object;\n\t};\n\tto: {\n\t\turl: string;\n\t\tpattern: Path;\n\t\tparams: object;\n\t};\n};\n\n/**\n * The animation object to use when no other animation matches.\n */\nexport const defaultAnimation: Animation = {\n\tfrom: '(.*)',\n\tto: '(.*)',\n\tout: (done) => done(),\n\tin: (done) => done()\n};\n\n/**\n * Compile animations to match functions and transitions\n */\nexport function compileAnimations(\n\tanimations: Animation[],\n\tmatchOptions?: MatchOptions\n): CompiledAnimation[] {\n\treturn animations.map(\n\t\t(animation): CompiledAnimation => compileAnimation(animation, matchOptions)\n\t);\n}\n\n/**\n * Compile path patterns to match functions and transitions\n */\nexport function compileAnimation(\n\tanimation: Animation,\n\tmatchOptions?: MatchOptions\n): CompiledAnimation {\n\tconst matchesFrom = matchPath(animation.from, matchOptions);\n\tconst matchesTo = matchPath(animation.to, matchOptions);\n\treturn { ...animation, matchesFrom, matchesTo };\n}\n\n/**\n * Rate animation based on the match\n */\nexport function rateAnimation(\n\tanimation: CompiledAnimation,\n\tfrom: string,\n\tto: string,\n\tname?: string\n): number {\n\tlet rating = 0;\n\n\t// Check if route patterns match\n\tconst fromMatched = animation.matchesFrom(from);\n\tconst toMatched = animation.matchesTo(to);\n\tif (fromMatched) {\n\t\trating += 1;\n\t}\n\tif (toMatched) {\n\t\trating += 1;\n\t}\n\n\t// Beat all others if custom name fits\n\tif (fromMatched && animation.to === name) {\n\t\trating += 2;\n\t}\n\n\treturn rating;\n}\n\n/**\n * Find the best matching animation given a visit object\n */\nexport function findAnimationForVisit(\n\tanimations: CompiledAnimation[],\n\tvisit: Visit\n): CompiledAnimation | null {\n\treturn findAnimation(animations, visit.from.url, visit.to.url, visit.animation.name);\n}\n\n/**\n * Find the best matching animation by ranking them against each other\n */\nexport function findAnimation(\n\tanimations: CompiledAnimation[],\n\tfrom: string,\n\tto: string,\n\tname?: string\n): CompiledAnimation | null {\n\tlet topRating = 0;\n\n\tconst animation: CompiledAnimation | null = animations.reduceRight(\n\t\t(bestMatch, animation) => {\n\t\t\tconst rating = rateAnimation(animation, from, to, name);\n\t\t\tif (rating >= topRating) {\n\t\t\t\ttopRating = rating;\n\t\t\t\treturn animation;\n\t\t\t} else {\n\t\t\t\treturn bestMatch;\n\t\t\t}\n\t\t},\n\t\tnull as CompiledAnimation | null\n\t);\n\n\treturn animation;\n}\n\n/**\n * Create an object with all the data passed into the animation handler function\n */\nexport function assembleAnimationData(\n\tanimation: CompiledAnimation,\n\tvisit: Visit,\n\tdirection: 'in' | 'out'\n): AnimationData {\n\tconst matchFrom = animation.matchesFrom(visit.from.url);\n\tconst matchTo = animation.matchesTo(visit.to.url!);\n\n\treturn {\n\t\tvisit,\n\t\tdirection,\n\t\tfrom: {\n\t\t\turl: visit.from.url,\n\t\t\tpattern: animation.from,\n\t\t\tparams: matchFrom ? matchFrom.params : {}\n\t\t},\n\t\tto: {\n\t\t\turl: visit.to.url!,\n\t\t\tpattern: animation.to,\n\t\t\tparams: matchTo ? matchTo.params : {}\n\t\t}\n\t};\n}\n\n/**\n * Run an animation handler function and resolve when it's done.\n */\nexport function runAnimation(animation: CompiledAnimation, data: AnimationData): Promise<void> {\n\tconst { direction } = data;\n\tconst animationFn = animation[direction];\n\tif (!animationFn) {\n\t\tconsole.warn(`Missing animation function for '${direction}' phase`);\n\t\treturn Promise.resolve();\n\t}\n\n\treturn new Promise((resolve) => {\n\t\t/* Sync API: Pass `done` callback into animation handler so it can resolve manually */\n\t\tconst result = animationFn(() => resolve(), data);\n\t\t/* Async API: Receive a promise from animation handler so we resolve it here */\n\t\tif (isPromise(result)) {\n\t\t\tresult.then(resolve);\n\t\t}\n\t});\n}\n","import Plugin from '@swup/plugin';\nimport { matchPath } from 'swup';\nimport type { Handler, Visit } from 'swup';\n\nimport {\n\tassembleAnimationData,\n\tcompileAnimations,\n\tdefaultAnimation,\n\tfindAnimationForVisit,\n\trunAnimation\n} from './animations.js';\nimport type { Animation, CompiledAnimation } from './animations.js';\n\ntype RequireKeys<T, K extends keyof T> = Partial<T> & Pick<T, K>;\n\ntype Options = {\n\t/** The selector for matching the main content area of the page. */\n\tanimations: Animation[];\n\t/** Options for matching paths. Directly passed into `path-to-regexp`. */\n\tmatchOptions: MatchOptions;\n};\n\ntype InitOptions = RequireKeys<Options, 'animations'>;\n\nexport type MatchOptions = Parameters<typeof matchPath>[1];\n\nexport type MatchFunction = ReturnType<typeof matchPath>;\n\nexport default class SwupJsPlugin extends Plugin {\n\tname = 'SwupJsPlugin';\n\n\trequires = { swup: '>=4' };\n\n\tdefaults: Options = {\n\t\tanimations: [],\n\t\tmatchOptions: {}\n\t};\n\n\toptions: Options;\n\n\tanimations: CompiledAnimation[] = [];\n\n\tconstructor(options: InitOptions) {\n\t\tsuper();\n\n\t\t// Backward compatibility: allow passing an array of animations directly\n\t\tif (Array.isArray(options)) {\n\t\t\toptions = { animations: options as Animation[] };\n\t\t}\n\n\t\tthis.options = { ...this.defaults, ...options };\n\t\tthis.options.animations.push(defaultAnimation);\n\t\tthis.animations = compileAnimations(this.options.animations, this.options.matchOptions);\n\t}\n\n\tmount() {\n\t\tthis.replace('animation:out:await', this.awaitOutAnimation, { priority: -1 });\n\t\tthis.replace('animation:in:await', this.awaitInAnimation, { priority: -1 });\n\t}\n\n\t/**\n\t * Replace swup's internal out-animation handler.\n\t * Finds and runs the 'in' animation for the current visit.\n\t */\n\tawaitOutAnimation: Handler<'animation:out:await'> = async (visit, { skip }) => {\n\t\tif (skip) return;\n\t\tawait this.findAndRunAnimation(visit, 'out');\n\t};\n\n\t/**\n\t * Replace swup's internal in-animation handler handler.\n\t * Finds and runs the 'in' animation for the current visit.\n\t */\n\tawaitInAnimation: Handler<'animation:in:await'> = async (visit, { skip }) => {\n\t\tif (skip) return;\n\t\tawait this.findAndRunAnimation(visit, 'in');\n\t};\n\n\t/**\n\t * Find the best matching animation for the visit and run its handler function.\n\t */\n\tasync findAndRunAnimation(visit: Visit, direction: 'in' | 'out'): Promise<void> {\n\t\tconst animation = findAnimationForVisit(this.animations, visit);\n\t\tif (animation) {\n\t\t\tconst data = assembleAnimationData(animation, visit, direction);\n\t\t\tawait runAnimation(animation, data);\n\t\t}\n\t}\n}\n"],"names":["n","r","String","split","map","parseInt","concat","slice","join","e","every","t","s","match","o","i","localeCompare","numeric","str","options","keys","re","_a","decode","x","pathname","m","exec","path","index","params","Object","create","undefined","key","name","modifier","prefix","suffix","value","length","regexpToFunction","pathToRegexp","escapeString","replace","flags","sensitive","RegExp","groupsRegex","execResult","source","push","pattern","regexpToRegexp","Array","isArray","paths","parts","arrayToRegexp","tokens","strict","_b","start","_c","end","_d","encode","_e","delimiter","_f","endsWith","endsWithRe","delimiterRe","route","_i","tokens_1","token","mod","endToken","isEndDelimited","indexOf","tokensToRegexp","char","type","count","j","TypeError","code","charCodeAt","lexer","prefixes","defaultPattern","result","tryConsume","mustConsume","consumeText","name_1","pattern_1","parse","stringToRegexp","defaultAnimation","from","to","out","done","in","Plugin","constructor","super","_this2","this","_this","matchOptions","requires","swup","defaults","animations","awaitOutAnimation","visit","_ref","skip","Promise","resolve","findAndRunAnimation","then","reject","awaitInAnimation","_ref2","animation","matchesFrom","matchPath","matchesTo","compileAnimation","mount","priority","direction","_this3","topRating","reduceRight","bestMatch","rating","fromMatched","rateAnimation","findAnimation","url","findAnimationForVisit","_temp","data","matchFrom","matchTo","assembleAnimationData","animationFn","console","warn","runAnimation"],"mappings":"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"}