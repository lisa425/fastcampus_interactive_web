{"version":3,"file":"index.module.js","sources":["../src/animations.ts","../src/index.ts"],"sourcesContent":["import { isPromise, matchPath } from 'swup';\nimport type { Path, Visit } from 'swup';\n\nimport { MatchFunction, MatchOptions } from './index.js';\n\n/**\n * Animation object as supplied by plugin users.\n * Contains path patterns and handler functions for in/out animation.\n */\nexport type Animation = {\n\t/** The path pattern to match the current url against. */\n\tfrom: Path;\n\t/** The path pattern to match the next url against. */\n\tto: Path;\n\t/** The function to call when the animation is triggered. */\n\tout: (done: () => void, data: AnimationData) => void | Promise<void>;\n\t/** The function to call when the animation is triggered. */\n\tin: (done: () => void, data: AnimationData) => void | Promise<void>;\n};\n\n/**\n * Compiled animation object with pre-optimized match functions.\n */\nexport type CompiledAnimation = Animation & {\n\t/** Match function to check if the `from` pattern matches a given URL */\n\tmatchesFrom: MatchFunction;\n\t/** Match function to check if the `to` pattern matches a given URL */\n\tmatchesTo: MatchFunction;\n};\n\n/**\n * Data object passed into the animation handler functions.\n */\nexport type AnimationData = {\n\tvisit: Visit;\n\tdirection: 'in' | 'out';\n\tfrom: {\n\t\turl: string;\n\t\tpattern: Path;\n\t\tparams: object;\n\t};\n\tto: {\n\t\turl: string;\n\t\tpattern: Path;\n\t\tparams: object;\n\t};\n};\n\n/**\n * The animation object to use when no other animation matches.\n */\nexport const defaultAnimation: Animation = {\n\tfrom: '(.*)',\n\tto: '(.*)',\n\tout: (done) => done(),\n\tin: (done) => done()\n};\n\n/**\n * Compile animations to match functions and transitions\n */\nexport function compileAnimations(\n\tanimations: Animation[],\n\tmatchOptions?: MatchOptions\n): CompiledAnimation[] {\n\treturn animations.map(\n\t\t(animation): CompiledAnimation => compileAnimation(animation, matchOptions)\n\t);\n}\n\n/**\n * Compile path patterns to match functions and transitions\n */\nexport function compileAnimation(\n\tanimation: Animation,\n\tmatchOptions?: MatchOptions\n): CompiledAnimation {\n\tconst matchesFrom = matchPath(animation.from, matchOptions);\n\tconst matchesTo = matchPath(animation.to, matchOptions);\n\treturn { ...animation, matchesFrom, matchesTo };\n}\n\n/**\n * Rate animation based on the match\n */\nexport function rateAnimation(\n\tanimation: CompiledAnimation,\n\tfrom: string,\n\tto: string,\n\tname?: string\n): number {\n\tlet rating = 0;\n\n\t// Check if route patterns match\n\tconst fromMatched = animation.matchesFrom(from);\n\tconst toMatched = animation.matchesTo(to);\n\tif (fromMatched) {\n\t\trating += 1;\n\t}\n\tif (toMatched) {\n\t\trating += 1;\n\t}\n\n\t// Beat all others if custom name fits\n\tif (fromMatched && animation.to === name) {\n\t\trating += 2;\n\t}\n\n\treturn rating;\n}\n\n/**\n * Find the best matching animation given a visit object\n */\nexport function findAnimationForVisit(\n\tanimations: CompiledAnimation[],\n\tvisit: Visit\n): CompiledAnimation | null {\n\treturn findAnimation(animations, visit.from.url, visit.to.url, visit.animation.name);\n}\n\n/**\n * Find the best matching animation by ranking them against each other\n */\nexport function findAnimation(\n\tanimations: CompiledAnimation[],\n\tfrom: string,\n\tto: string,\n\tname?: string\n): CompiledAnimation | null {\n\tlet topRating = 0;\n\n\tconst animation: CompiledAnimation | null = animations.reduceRight(\n\t\t(bestMatch, animation) => {\n\t\t\tconst rating = rateAnimation(animation, from, to, name);\n\t\t\tif (rating >= topRating) {\n\t\t\t\ttopRating = rating;\n\t\t\t\treturn animation;\n\t\t\t} else {\n\t\t\t\treturn bestMatch;\n\t\t\t}\n\t\t},\n\t\tnull as CompiledAnimation | null\n\t);\n\n\treturn animation;\n}\n\n/**\n * Create an object with all the data passed into the animation handler function\n */\nexport function assembleAnimationData(\n\tanimation: CompiledAnimation,\n\tvisit: Visit,\n\tdirection: 'in' | 'out'\n): AnimationData {\n\tconst matchFrom = animation.matchesFrom(visit.from.url);\n\tconst matchTo = animation.matchesTo(visit.to.url!);\n\n\treturn {\n\t\tvisit,\n\t\tdirection,\n\t\tfrom: {\n\t\t\turl: visit.from.url,\n\t\t\tpattern: animation.from,\n\t\t\tparams: matchFrom ? matchFrom.params : {}\n\t\t},\n\t\tto: {\n\t\t\turl: visit.to.url!,\n\t\t\tpattern: animation.to,\n\t\t\tparams: matchTo ? matchTo.params : {}\n\t\t}\n\t};\n}\n\n/**\n * Run an animation handler function and resolve when it's done.\n */\nexport function runAnimation(animation: CompiledAnimation, data: AnimationData): Promise<void> {\n\tconst { direction } = data;\n\tconst animationFn = animation[direction];\n\tif (!animationFn) {\n\t\tconsole.warn(`Missing animation function for '${direction}' phase`);\n\t\treturn Promise.resolve();\n\t}\n\n\treturn new Promise((resolve) => {\n\t\t/* Sync API: Pass `done` callback into animation handler so it can resolve manually */\n\t\tconst result = animationFn(() => resolve(), data);\n\t\t/* Async API: Receive a promise from animation handler so we resolve it here */\n\t\tif (isPromise(result)) {\n\t\t\tresult.then(resolve);\n\t\t}\n\t});\n}\n","import Plugin from '@swup/plugin';\nimport { matchPath } from 'swup';\nimport type { Handler, Visit } from 'swup';\n\nimport {\n\tassembleAnimationData,\n\tcompileAnimations,\n\tdefaultAnimation,\n\tfindAnimationForVisit,\n\trunAnimation\n} from './animations.js';\nimport type { Animation, CompiledAnimation } from './animations.js';\n\ntype RequireKeys<T, K extends keyof T> = Partial<T> & Pick<T, K>;\n\ntype Options = {\n\t/** The selector for matching the main content area of the page. */\n\tanimations: Animation[];\n\t/** Options for matching paths. Directly passed into `path-to-regexp`. */\n\tmatchOptions: MatchOptions;\n};\n\ntype InitOptions = RequireKeys<Options, 'animations'>;\n\nexport type MatchOptions = Parameters<typeof matchPath>[1];\n\nexport type MatchFunction = ReturnType<typeof matchPath>;\n\nexport default class SwupJsPlugin extends Plugin {\n\tname = 'SwupJsPlugin';\n\n\trequires = { swup: '>=4' };\n\n\tdefaults: Options = {\n\t\tanimations: [],\n\t\tmatchOptions: {}\n\t};\n\n\toptions: Options;\n\n\tanimations: CompiledAnimation[] = [];\n\n\tconstructor(options: InitOptions) {\n\t\tsuper();\n\n\t\t// Backward compatibility: allow passing an array of animations directly\n\t\tif (Array.isArray(options)) {\n\t\t\toptions = { animations: options as Animation[] };\n\t\t}\n\n\t\tthis.options = { ...this.defaults, ...options };\n\t\tthis.options.animations.push(defaultAnimation);\n\t\tthis.animations = compileAnimations(this.options.animations, this.options.matchOptions);\n\t}\n\n\tmount() {\n\t\tthis.replace('animation:out:await', this.awaitOutAnimation, { priority: -1 });\n\t\tthis.replace('animation:in:await', this.awaitInAnimation, { priority: -1 });\n\t}\n\n\t/**\n\t * Replace swup's internal out-animation handler.\n\t * Finds and runs the 'in' animation for the current visit.\n\t */\n\tawaitOutAnimation: Handler<'animation:out:await'> = async (visit, { skip }) => {\n\t\tif (skip) return;\n\t\tawait this.findAndRunAnimation(visit, 'out');\n\t};\n\n\t/**\n\t * Replace swup's internal in-animation handler handler.\n\t * Finds and runs the 'in' animation for the current visit.\n\t */\n\tawaitInAnimation: Handler<'animation:in:await'> = async (visit, { skip }) => {\n\t\tif (skip) return;\n\t\tawait this.findAndRunAnimation(visit, 'in');\n\t};\n\n\t/**\n\t * Find the best matching animation for the visit and run its handler function.\n\t */\n\tasync findAndRunAnimation(visit: Visit, direction: 'in' | 'out'): Promise<void> {\n\t\tconst animation = findAnimationForVisit(this.animations, visit);\n\t\tif (animation) {\n\t\t\tconst data = assembleAnimationData(animation, visit, direction);\n\t\t\tawait runAnimation(animation, data);\n\t\t}\n\t}\n}\n"],"names":["defaultAnimation","from","to","out","done","in","SwupJsPlugin","Plugin","constructor","options","super","_this2","this","_this","matchOptions","name","requires","swup","defaults","animations","awaitOutAnimation","visit","_ref","skip","Promise","resolve","findAndRunAnimation","then","e","reject","awaitInAnimation","_ref2","Array","isArray","push","map","animation","matchesFrom","matchPath","matchesTo","compileAnimation","mount","replace","priority","direction","_this3","topRating","reduceRight","bestMatch","rating","fromMatched","rateAnimation","findAnimation","url","findAnimationForVisit","_temp","data","matchFrom","matchTo","pattern","params","assembleAnimationData","animationFn","result","isPromise","console","warn","runAnimation"],"mappings":"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"}