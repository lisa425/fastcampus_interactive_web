{"version":3,"file":"index.modern.js","sources":["../src/animations.ts","../src/index.ts"],"sourcesContent":["import { isPromise, matchPath } from 'swup';\nimport type { Path, Visit } from 'swup';\n\nimport { MatchFunction, MatchOptions } from './index.js';\n\n/**\n * Animation object as supplied by plugin users.\n * Contains path patterns and handler functions for in/out animation.\n */\nexport type Animation = {\n\t/** The path pattern to match the current url against. */\n\tfrom: Path;\n\t/** The path pattern to match the next url against. */\n\tto: Path;\n\t/** The function to call when the animation is triggered. */\n\tout: (done: () => void, data: AnimationData) => void | Promise<void>;\n\t/** The function to call when the animation is triggered. */\n\tin: (done: () => void, data: AnimationData) => void | Promise<void>;\n};\n\n/**\n * Compiled animation object with pre-optimized match functions.\n */\nexport type CompiledAnimation = Animation & {\n\t/** Match function to check if the `from` pattern matches a given URL */\n\tmatchesFrom: MatchFunction;\n\t/** Match function to check if the `to` pattern matches a given URL */\n\tmatchesTo: MatchFunction;\n};\n\n/**\n * Data object passed into the animation handler functions.\n */\nexport type AnimationData = {\n\tvisit: Visit;\n\tdirection: 'in' | 'out';\n\tfrom: {\n\t\turl: string;\n\t\tpattern: Path;\n\t\tparams: object;\n\t};\n\tto: {\n\t\turl: string;\n\t\tpattern: Path;\n\t\tparams: object;\n\t};\n};\n\n/**\n * The animation object to use when no other animation matches.\n */\nexport const defaultAnimation: Animation = {\n\tfrom: '(.*)',\n\tto: '(.*)',\n\tout: (done) => done(),\n\tin: (done) => done()\n};\n\n/**\n * Compile animations to match functions and transitions\n */\nexport function compileAnimations(\n\tanimations: Animation[],\n\tmatchOptions?: MatchOptions\n): CompiledAnimation[] {\n\treturn animations.map(\n\t\t(animation): CompiledAnimation => compileAnimation(animation, matchOptions)\n\t);\n}\n\n/**\n * Compile path patterns to match functions and transitions\n */\nexport function compileAnimation(\n\tanimation: Animation,\n\tmatchOptions?: MatchOptions\n): CompiledAnimation {\n\tconst matchesFrom = matchPath(animation.from, matchOptions);\n\tconst matchesTo = matchPath(animation.to, matchOptions);\n\treturn { ...animation, matchesFrom, matchesTo };\n}\n\n/**\n * Rate animation based on the match\n */\nexport function rateAnimation(\n\tanimation: CompiledAnimation,\n\tfrom: string,\n\tto: string,\n\tname?: string\n): number {\n\tlet rating = 0;\n\n\t// Check if route patterns match\n\tconst fromMatched = animation.matchesFrom(from);\n\tconst toMatched = animation.matchesTo(to);\n\tif (fromMatched) {\n\t\trating += 1;\n\t}\n\tif (toMatched) {\n\t\trating += 1;\n\t}\n\n\t// Beat all others if custom name fits\n\tif (fromMatched && animation.to === name) {\n\t\trating += 2;\n\t}\n\n\treturn rating;\n}\n\n/**\n * Find the best matching animation given a visit object\n */\nexport function findAnimationForVisit(\n\tanimations: CompiledAnimation[],\n\tvisit: Visit\n): CompiledAnimation | null {\n\treturn findAnimation(animations, visit.from.url, visit.to.url, visit.animation.name);\n}\n\n/**\n * Find the best matching animation by ranking them against each other\n */\nexport function findAnimation(\n\tanimations: CompiledAnimation[],\n\tfrom: string,\n\tto: string,\n\tname?: string\n): CompiledAnimation | null {\n\tlet topRating = 0;\n\n\tconst animation: CompiledAnimation | null = animations.reduceRight(\n\t\t(bestMatch, animation) => {\n\t\t\tconst rating = rateAnimation(animation, from, to, name);\n\t\t\tif (rating >= topRating) {\n\t\t\t\ttopRating = rating;\n\t\t\t\treturn animation;\n\t\t\t} else {\n\t\t\t\treturn bestMatch;\n\t\t\t}\n\t\t},\n\t\tnull as CompiledAnimation | null\n\t);\n\n\treturn animation;\n}\n\n/**\n * Create an object with all the data passed into the animation handler function\n */\nexport function assembleAnimationData(\n\tanimation: CompiledAnimation,\n\tvisit: Visit,\n\tdirection: 'in' | 'out'\n): AnimationData {\n\tconst matchFrom = animation.matchesFrom(visit.from.url);\n\tconst matchTo = animation.matchesTo(visit.to.url!);\n\n\treturn {\n\t\tvisit,\n\t\tdirection,\n\t\tfrom: {\n\t\t\turl: visit.from.url,\n\t\t\tpattern: animation.from,\n\t\t\tparams: matchFrom ? matchFrom.params : {}\n\t\t},\n\t\tto: {\n\t\t\turl: visit.to.url!,\n\t\t\tpattern: animation.to,\n\t\t\tparams: matchTo ? matchTo.params : {}\n\t\t}\n\t};\n}\n\n/**\n * Run an animation handler function and resolve when it's done.\n */\nexport function runAnimation(animation: CompiledAnimation, data: AnimationData): Promise<void> {\n\tconst { direction } = data;\n\tconst animationFn = animation[direction];\n\tif (!animationFn) {\n\t\tconsole.warn(`Missing animation function for '${direction}' phase`);\n\t\treturn Promise.resolve();\n\t}\n\n\treturn new Promise((resolve) => {\n\t\t/* Sync API: Pass `done` callback into animation handler so it can resolve manually */\n\t\tconst result = animationFn(() => resolve(), data);\n\t\t/* Async API: Receive a promise from animation handler so we resolve it here */\n\t\tif (isPromise(result)) {\n\t\t\tresult.then(resolve);\n\t\t}\n\t});\n}\n","import Plugin from '@swup/plugin';\nimport { matchPath } from 'swup';\nimport type { Handler, Visit } from 'swup';\n\nimport {\n\tassembleAnimationData,\n\tcompileAnimations,\n\tdefaultAnimation,\n\tfindAnimationForVisit,\n\trunAnimation\n} from './animations.js';\nimport type { Animation, CompiledAnimation } from './animations.js';\n\ntype RequireKeys<T, K extends keyof T> = Partial<T> & Pick<T, K>;\n\ntype Options = {\n\t/** The selector for matching the main content area of the page. */\n\tanimations: Animation[];\n\t/** Options for matching paths. Directly passed into `path-to-regexp`. */\n\tmatchOptions: MatchOptions;\n};\n\ntype InitOptions = RequireKeys<Options, 'animations'>;\n\nexport type MatchOptions = Parameters<typeof matchPath>[1];\n\nexport type MatchFunction = ReturnType<typeof matchPath>;\n\nexport default class SwupJsPlugin extends Plugin {\n\tname = 'SwupJsPlugin';\n\n\trequires = { swup: '>=4' };\n\n\tdefaults: Options = {\n\t\tanimations: [],\n\t\tmatchOptions: {}\n\t};\n\n\toptions: Options;\n\n\tanimations: CompiledAnimation[] = [];\n\n\tconstructor(options: InitOptions) {\n\t\tsuper();\n\n\t\t// Backward compatibility: allow passing an array of animations directly\n\t\tif (Array.isArray(options)) {\n\t\t\toptions = { animations: options as Animation[] };\n\t\t}\n\n\t\tthis.options = { ...this.defaults, ...options };\n\t\tthis.options.animations.push(defaultAnimation);\n\t\tthis.animations = compileAnimations(this.options.animations, this.options.matchOptions);\n\t}\n\n\tmount() {\n\t\tthis.replace('animation:out:await', this.awaitOutAnimation, { priority: -1 });\n\t\tthis.replace('animation:in:await', this.awaitInAnimation, { priority: -1 });\n\t}\n\n\t/**\n\t * Replace swup's internal out-animation handler.\n\t * Finds and runs the 'in' animation for the current visit.\n\t */\n\tawaitOutAnimation: Handler<'animation:out:await'> = async (visit, { skip }) => {\n\t\tif (skip) return;\n\t\tawait this.findAndRunAnimation(visit, 'out');\n\t};\n\n\t/**\n\t * Replace swup's internal in-animation handler handler.\n\t * Finds and runs the 'in' animation for the current visit.\n\t */\n\tawaitInAnimation: Handler<'animation:in:await'> = async (visit, { skip }) => {\n\t\tif (skip) return;\n\t\tawait this.findAndRunAnimation(visit, 'in');\n\t};\n\n\t/**\n\t * Find the best matching animation for the visit and run its handler function.\n\t */\n\tasync findAndRunAnimation(visit: Visit, direction: 'in' | 'out'): Promise<void> {\n\t\tconst animation = findAnimationForVisit(this.animations, visit);\n\t\tif (animation) {\n\t\t\tconst data = assembleAnimationData(animation, visit, direction);\n\t\t\tawait runAnimation(animation, data);\n\t\t}\n\t}\n}\n"],"names":["defaultAnimation","from","to","out","done","in","SwupJsPlugin","Plugin","constructor","options","_this","matchOptions","super","this","name","requires","swup","defaults","animations","awaitOutAnimation","async","visit","skip","findAndRunAnimation","awaitInAnimation","Array","isArray","_extends","push","map","animation","matchesFrom","matchPath","matchesTo","compileAnimation","mount","replace","priority","direction","topRating","reduceRight","bestMatch","rating","fromMatched","rateAnimation","findAnimation","url","findAnimationForVisit","data","matchFrom","matchTo","pattern","params","assembleAnimationData","animationFn","Promise","resolve","result","isPromise","then","console","warn","runAnimation"],"mappings":"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"}