{
  "version": 3,
  "sources": ["../../@swup/plugin/src/versionSatisfies.ts", "../../@swup/plugin/src/index.ts", "../../@swup/plugin/src/pluginRequirements.ts", "../../@swup/js-plugin/src/animations.ts", "../../@swup/js-plugin/src/index.ts"],
  "sourcesContent": ["type Comparator = '>' | '>=' | '<' | '<=';\n\n// Fill versions to exactly 3 decimals\nexport const normalizeVersion = (version: string): string => {\n\treturn String(version)\n\t\t.split('.')\n\t\t.map(segment => String(parseInt(segment || '0', 10)))\n\t\t.concat(['0', '0'])\n\t\t.slice(0, 3)\n\t\t.join('.');\n};\n\n// Numerically compare version strings after normalizing them\nexport const compareVersion = (a: string, b: string): number => {\n\ta = normalizeVersion(a);\n\tb = normalizeVersion(b);\n\treturn a.localeCompare(b, undefined, { numeric: true });\n};\n\n// Apply a comparator (equals, greater-than, etc) by its symbol to a sort comparison\nconst applyComparator = (comparisonResult: number, comparator: Comparator) => {\n\tconst comparators = {\n\t\t'': (r: number) => r === 0,\n\t\t'>': (r: number) => r > 0,\n\t\t'>=': (r: number) => r >= 0,\n\t\t'<': (r: number) => r < 0,\n\t\t'<=': (r: number) => r <= 0\n\t};\n\tconst comparatorFn = comparators[comparator] || comparators[''];\n\treturn comparatorFn(comparisonResult);\n};\n\n/**\n * Check if a version satisfies all given version requirements\n *\n * versionSatisfies('2.1.0', ['>=2', '<4']) // true\n * versionSatisfies('2.1.0', ['5']) // false\n *\n * @param {string} installed Installed version\n * @param {Array.<string>} requirements Array of requirements that must be satisfied\n * @returns boolean\n */\nexport const versionSatisfies = (installed: string, requirements: string[]) => {\n\treturn requirements.every((required) => {\n\t\tconst [, comparator, version] = required.match(/^([\\D]+)?(.*)$/) || [];\n\t\tconst comparisonResult = compareVersion(installed, version);\n\t\treturn applyComparator(comparisonResult, (comparator as Comparator) || '>=');\n\t});\n};\n", "import type Swup from 'swup';\nimport type { Plugin, HookName, HookOptions, HookUnregister, Handler } from 'swup';\nimport { checkDependencyVersion } from './pluginRequirements.js';\n\nfunction isBound(func: Function) {\n\treturn func.name.startsWith('bound ') && !func.hasOwnProperty('prototype');\n}\n\nexport default abstract class SwupPlugin implements Plugin {\n\t/** Name of the plugin */\n\tabstract name: string;\n\n\t/** Identify as a swup plugin */\n\tisSwupPlugin: true = true;\n\n\t// Swup instance, assigned by swup itself\n\tswup!: Swup;\n\n\t/** Version of this plugin. Currently not in use, defined here for backward compatiblity. */\n\tversion?: string;\n\n\t/** Version requirements of this plugin. Example: `{ swup: '>=4' }` */\n\trequires?: Record<string, string | string[]> = {};\n\n\t// List of hook handlers to unregister on unmount\n\tprivate handlersToUnregister: HookUnregister[] = [];\n\n\t/** Run on mount */\n\tmount() {\n\t\t// this is mount method rewritten by class extending\n\t\t// and is executed when swup is enabled with plugin\n\t}\n\n\t/** Run on unmount */\n\tunmount() {\n\t\t// this is unmount method rewritten by class extending\n\t\t// and is executed when swup with plugin is disabled\n\n\t\t// Unsubscribe all registered hook handlers\n\t\tthis.handlersToUnregister.forEach((unregister) => unregister());\n\t\tthis.handlersToUnregister = [];\n\t}\n\n\t_beforeMount(): void {\n\t\tif (!this.name) {\n\t\t\tthrow new Error('You must define a name of plugin when creating a class.');\n\t\t}\n\t}\n\n\t_afterUnmount(): void {\n\t\t// here for any future hidden auto-cleanup\n\t}\n\n\t_checkRequirements(): boolean {\n\t\tif (typeof this.requires !== 'object') {\n\t\t\treturn true;\n\t\t}\n\n\t\tObject.entries(this.requires).forEach(([dependency, versions]) => {\n\t\t\tversions = Array.isArray(versions) ? versions : [versions];\n\t\t\tif (!checkDependencyVersion(dependency, versions, this.swup)) {\n\t\t\t\tconst requirement = `${dependency} ${versions.join(', ')}`;\n\t\t\t\tthrow new Error(`Plugin version mismatch: ${this.name} requires ${requirement}`);\n\t\t\t}\n\t\t});\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Register a new hook handler.\n\t *\n\t * On plugin unmount, the handler will automatically be unregistered.\n\t * The handler function is lexically bound to the plugin instance for convenience.\n\t * @see swup.hooks.on\n\t */\n\tprotected on<T extends HookName>(hook: T, handler: Handler<T>, options: HookOptions = {}): HookUnregister {\n\t\thandler = !isBound(handler) ? handler.bind(this) : handler;\n\t\tconst unregister = this.swup.hooks.on(hook, handler, options);\n\t\tthis.handlersToUnregister.push(unregister);\n\t\treturn unregister;\n\t}\n\n\tprotected once<T extends HookName>(hook: T, handler: Handler<T>, options: HookOptions = {}): HookUnregister {\n\t\treturn this.on(hook, handler, { ...options, once: true });\n\t}\n\n\tprotected before<T extends HookName>(hook: T, handler: Handler<T>, options: HookOptions = {}): HookUnregister {\n\t\treturn this.on(hook, handler, { ...options, before: true });\n\t}\n\n\tprotected replace<T extends HookName>(hook: T, handler: Handler<T>, options: HookOptions = {}): HookUnregister {\n\t\treturn this.on(hook, handler, { ...options, replace: true });\n\t}\n\n\tprotected off<T extends HookName>(hook: T, handler?: Handler<T>): void {\n\t\treturn this.swup.hooks.off(hook, handler!);\n\t}\n}\n", "import type Swup from 'swup';\n\nimport { versionSatisfies } from './versionSatisfies.js';\n\nfunction getInstalledDependencyVersion(dependency: string, swup: Swup): string {\n\tif (dependency === 'swup') {\n\t\treturn swup.version ?? '';\n\t} else {\n\t\t// Circular type dependency?\n\t\t// findPlugin returns swup's Plugin type which is not up-to-date\n\t\t// with the actual Plugin type from index.ts\n\t\tconst plugin = swup.findPlugin(dependency);\n\t\treturn plugin?.version ?? '';\n\t}\n}\n\nexport function checkDependencyVersion(\n\tdependency: string,\n\trequirements: string[],\n\tswup: Swup\n): boolean {\n\tconst version = getInstalledDependencyVersion(dependency, swup);\n\tif (version) {\n\t\treturn versionSatisfies(version, requirements);\n\t} else {\n\t\treturn false;\n\t}\n}\n", "import { isPromise, matchPath } from 'swup';\nimport type { Path, Visit } from 'swup';\n\nimport { MatchFunction, MatchOptions } from './index.js';\n\n/**\n * Animation object as supplied by plugin users.\n * Contains path patterns and handler functions for in/out animation.\n */\nexport type Animation = {\n\t/** The path pattern to match the current url against. */\n\tfrom: Path;\n\t/** The path pattern to match the next url against. */\n\tto: Path;\n\t/** The function to call when the animation is triggered. */\n\tout: (done: () => void, data: AnimationData) => void | Promise<void>;\n\t/** The function to call when the animation is triggered. */\n\tin: (done: () => void, data: AnimationData) => void | Promise<void>;\n};\n\n/**\n * Compiled animation object with pre-optimized match functions.\n */\nexport type CompiledAnimation = Animation & {\n\t/** Match function to check if the `from` pattern matches a given URL */\n\tmatchesFrom: MatchFunction;\n\t/** Match function to check if the `to` pattern matches a given URL */\n\tmatchesTo: MatchFunction;\n};\n\n/**\n * Data object passed into the animation handler functions.\n */\nexport type AnimationData = {\n\tvisit: Visit;\n\tdirection: 'in' | 'out';\n\tfrom: {\n\t\turl: string;\n\t\tpattern: Path;\n\t\tparams: object;\n\t};\n\tto: {\n\t\turl: string;\n\t\tpattern: Path;\n\t\tparams: object;\n\t};\n};\n\n/**\n * The animation object to use when no other animation matches.\n */\nexport const defaultAnimation: Animation = {\n\tfrom: '(.*)',\n\tto: '(.*)',\n\tout: (done) => done(),\n\tin: (done) => done()\n};\n\n/**\n * Compile animations to match functions and transitions\n */\nexport function compileAnimations(\n\tanimations: Animation[],\n\tmatchOptions?: MatchOptions\n): CompiledAnimation[] {\n\treturn animations.map(\n\t\t(animation): CompiledAnimation => compileAnimation(animation, matchOptions)\n\t);\n}\n\n/**\n * Compile path patterns to match functions and transitions\n */\nexport function compileAnimation(\n\tanimation: Animation,\n\tmatchOptions?: MatchOptions\n): CompiledAnimation {\n\tconst matchesFrom = matchPath(animation.from, matchOptions);\n\tconst matchesTo = matchPath(animation.to, matchOptions);\n\treturn { ...animation, matchesFrom, matchesTo };\n}\n\n/**\n * Rate animation based on the match\n */\nexport function rateAnimation(\n\tanimation: CompiledAnimation,\n\tfrom: string,\n\tto: string,\n\tname?: string\n): number {\n\tlet rating = 0;\n\n\t// Check if route patterns match\n\tconst fromMatched = animation.matchesFrom(from);\n\tconst toMatched = animation.matchesTo(to);\n\tif (fromMatched) {\n\t\trating += 1;\n\t}\n\tif (toMatched) {\n\t\trating += 1;\n\t}\n\n\t// Beat all others if custom name fits\n\tif (fromMatched && animation.to === name) {\n\t\trating += 2;\n\t}\n\n\treturn rating;\n}\n\n/**\n * Find the best matching animation given a visit object\n */\nexport function findAnimationForVisit(\n\tanimations: CompiledAnimation[],\n\tvisit: Visit\n): CompiledAnimation | null {\n\treturn findAnimation(animations, visit.from.url, visit.to.url, visit.animation.name);\n}\n\n/**\n * Find the best matching animation by ranking them against each other\n */\nexport function findAnimation(\n\tanimations: CompiledAnimation[],\n\tfrom: string,\n\tto: string,\n\tname?: string\n): CompiledAnimation | null {\n\tlet topRating = 0;\n\n\tconst animation: CompiledAnimation | null = animations.reduceRight(\n\t\t(bestMatch, animation) => {\n\t\t\tconst rating = rateAnimation(animation, from, to, name);\n\t\t\tif (rating >= topRating) {\n\t\t\t\ttopRating = rating;\n\t\t\t\treturn animation;\n\t\t\t} else {\n\t\t\t\treturn bestMatch;\n\t\t\t}\n\t\t},\n\t\tnull as CompiledAnimation | null\n\t);\n\n\treturn animation;\n}\n\n/**\n * Create an object with all the data passed into the animation handler function\n */\nexport function assembleAnimationData(\n\tanimation: CompiledAnimation,\n\tvisit: Visit,\n\tdirection: 'in' | 'out'\n): AnimationData {\n\tconst matchFrom = animation.matchesFrom(visit.from.url);\n\tconst matchTo = animation.matchesTo(visit.to.url!);\n\n\treturn {\n\t\tvisit,\n\t\tdirection,\n\t\tfrom: {\n\t\t\turl: visit.from.url,\n\t\t\tpattern: animation.from,\n\t\t\tparams: matchFrom ? matchFrom.params : {}\n\t\t},\n\t\tto: {\n\t\t\turl: visit.to.url!,\n\t\t\tpattern: animation.to,\n\t\t\tparams: matchTo ? matchTo.params : {}\n\t\t}\n\t};\n}\n\n/**\n * Run an animation handler function and resolve when it's done.\n */\nexport function runAnimation(animation: CompiledAnimation, data: AnimationData): Promise<void> {\n\tconst { direction } = data;\n\tconst animationFn = animation[direction];\n\tif (!animationFn) {\n\t\tconsole.warn(`Missing animation function for '${direction}' phase`);\n\t\treturn Promise.resolve();\n\t}\n\n\treturn new Promise((resolve) => {\n\t\t/* Sync API: Pass `done` callback into animation handler so it can resolve manually */\n\t\tconst result = animationFn(() => resolve(), data);\n\t\t/* Async API: Receive a promise from animation handler so we resolve it here */\n\t\tif (isPromise(result)) {\n\t\t\tresult.then(resolve);\n\t\t}\n\t});\n}\n", "import Plugin from '@swup/plugin';\nimport { matchPath } from 'swup';\nimport type { Handler, Visit } from 'swup';\n\nimport {\n\tassembleAnimationData,\n\tcompileAnimations,\n\tdefaultAnimation,\n\tfindAnimationForVisit,\n\trunAnimation\n} from './animations.js';\nimport type { Animation, CompiledAnimation } from './animations.js';\n\ntype RequireKeys<T, K extends keyof T> = Partial<T> & Pick<T, K>;\n\ntype Options = {\n\t/** The selector for matching the main content area of the page. */\n\tanimations: Animation[];\n\t/** Options for matching paths. Directly passed into `path-to-regexp`. */\n\tmatchOptions: MatchOptions;\n};\n\ntype InitOptions = RequireKeys<Options, 'animations'>;\n\nexport type MatchOptions = Parameters<typeof matchPath>[1];\n\nexport type MatchFunction = ReturnType<typeof matchPath>;\n\nexport default class SwupJsPlugin extends Plugin {\n\tname = 'SwupJsPlugin';\n\n\trequires = { swup: '>=4' };\n\n\tdefaults: Options = {\n\t\tanimations: [],\n\t\tmatchOptions: {}\n\t};\n\n\toptions: Options;\n\n\tanimations: CompiledAnimation[] = [];\n\n\tconstructor(options: InitOptions) {\n\t\tsuper();\n\n\t\t// Backward compatibility: allow passing an array of animations directly\n\t\tif (Array.isArray(options)) {\n\t\t\toptions = { animations: options as Animation[] };\n\t\t}\n\n\t\tthis.options = { ...this.defaults, ...options };\n\t\tthis.options.animations.push(defaultAnimation);\n\t\tthis.animations = compileAnimations(this.options.animations, this.options.matchOptions);\n\t}\n\n\tmount() {\n\t\tthis.replace('animation:out:await', this.awaitOutAnimation, { priority: -1 });\n\t\tthis.replace('animation:in:await', this.awaitInAnimation, { priority: -1 });\n\t}\n\n\t/**\n\t * Replace swup's internal out-animation handler.\n\t * Finds and runs the 'in' animation for the current visit.\n\t */\n\tawaitOutAnimation: Handler<'animation:out:await'> = async (visit, { skip }) => {\n\t\tif (skip) return;\n\t\tawait this.findAndRunAnimation(visit, 'out');\n\t};\n\n\t/**\n\t * Replace swup's internal in-animation handler handler.\n\t * Finds and runs the 'in' animation for the current visit.\n\t */\n\tawaitInAnimation: Handler<'animation:in:await'> = async (visit, { skip }) => {\n\t\tif (skip) return;\n\t\tawait this.findAndRunAnimation(visit, 'in');\n\t};\n\n\t/**\n\t * Find the best matching animation for the visit and run its handler function.\n\t */\n\tasync findAndRunAnimation(visit: Visit, direction: 'in' | 'out'): Promise<void> {\n\t\tconst animation = findAnimationForVisit(this.animations, visit);\n\t\tif (animation) {\n\t\t\tconst data = assembleAnimationData(animation, visit, direction);\n\t\t\tawait runAnimation(animation, data);\n\t\t}\n\t}\n}\n"],
  "mappings": "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",
  "names": ["normalizeVersion", "version", "String", "split", "map", "segment", "parseInt", "concat", "slice", "join", "SwupPlugin", "constructor", "this", "isSwupPlugin", "swup", "requires", "handlersToUnregister", "mount", "unmount", "forEach", "unregister", "_beforeMount", "name", "Error", "_afterUnmount", "_checkRequirements", "Object", "entries", "dependency", "versions", "requirements", "_swup$version", "_plugin$version", "plugin", "findPlugin", "versionSatisfies", "installed", "every", "required", "comparator", "match", "compareVersion", "a", "b", "applyComparator", "comparisonResult", "comparators", "r", "localeCompare", "numeric", "Array", "isArray", "requirement", "on", "hook", "handler", "options", "func", "startsWith", "hasOwnProperty", "bind", "hooks", "push", "once", "_extends", "before", "replace", "off", "defaultAnimation", "from", "to", "out", "done", "in", "SwupJsPlugin", "Plugin", "constructor", "options", "_this", "matchOptions", "super", "this", "name", "requires", "swup", "defaults", "animations", "awaitOutAnimation", "async", "visit", "skip", "findAndRunAnimation", "awaitInAnimation", "Array", "isArray", "_extends", "push", "map", "animation", "matchesFrom", "matchPath", "matchesTo", "mount", "replace", "priority", "direction", "topRating", "reduceRight", "bestMatch", "rating", "fromMatched", "url", "data", "matchFrom", "matchTo", "pattern", "params", "animationFn", "Promise", "resolve", "result", "isPromise", "then", "console", "warn"]
}
